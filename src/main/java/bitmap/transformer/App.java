/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package bitmap.transformer;

import javax.imageio.ImageIO;
import java.awt.geom.AffineTransform;
import java.awt.image.AffineTransformOp;
import java.awt.image.BufferedImage;
import java.awt.image.RenderedImage;
import java.io.File;
import java.io.IOException;

public class App {
    public static void main(String[] args) {
        //String filePath = args[0];
        //String savePath = args[1];

        //String filePath = "src/main/resources/mario.bmp";
        //String savePath = "src/main/resources/savedMario.bmp";
        BufferedImage thePic = getImg(args[0]);

        File savePath = new File(args[1]);
        if(savePath.isDirectory()) {

            switch (args[2]) {
                case "whiteOut":
                    giveImg(pixelPlay(thePic), savePath);
                    break;
                case "rotate":
                    giveImg(ninetyDegreesTurned(thePic), savePath);
                    break;
                case "invert":
                    giveImg(invertedPixel(thePic), savePath);
                    break;
                default:
                    System.out.println("Unable to find mod, please use one of these options for you third argument:\nwhiteOut <---\nrotate   <---\ninvert   <---\n");
            }
        }else{
            System.out.println("Unable to save file. Please check path.");
            System.exit(0);
        }
    }

    public static File checkSavePath(String path)
    {
        
    }

    public static BufferedImage getImg(String file) {
        BufferedImage img = null;
        try {
            img = ImageIO.read(new File(file));
        } catch (IOException e) {
            System.out.println("Unable to find the image. Please check path");
            System.exit(0);
        }
        return img;
    }

    public static void giveImg(BufferedImage potato, File savePath) { // , String argsPath

        try {
            RenderedImage finalImg = potato;

            //File path = new File(savePath);
            ImageIO.write(finalImg, "bmp", savePath);
        } catch (IOException e) {
            System.out.println("We had a problem saving image.");
            System.exit(0);
        }
    }

    public static BufferedImage ninetyDegreesTurned(BufferedImage butcheredImg) {
        // https://blog.idrsolutions.com/2019/05/image-rotation-in-java/ to know
        // how to rotate a photo.
        double rads = Math.toRadians(90);
        double sin = Math.abs(Math.sin(rads));
        double cos = Math.abs(Math.cos(rads));
        int w = (int) Math.floor(butcheredImg.getWidth() * cos + butcheredImg.getHeight() * sin);
        int h = (int) Math.floor(butcheredImg.getHeight() * cos + butcheredImg.getWidth() * sin);
        BufferedImage rotatedImage = new BufferedImage(w, h, butcheredImg.getType());
        AffineTransform at = new AffineTransform();
        at.translate(w / 2, h / 2);
        at.rotate(rads, 0, 0);
        at.translate(-rotatedImage.getWidth() / 2, -rotatedImage.getHeight() / 2);
        AffineTransformOp rotateOp = new AffineTransformOp(at, AffineTransformOp.TYPE_BILINEAR);
        rotateOp.filter(butcheredImg, rotatedImage);

        return rotatedImage;
    }

    public static BufferedImage pixelPlay(BufferedImage butcheredImg) {
        int width = butcheredImg.getWidth();
        int height = butcheredImg.getHeight();

        int pixel = butcheredImg.getRGB(0, 0);

        for (int i = 0; i < width; i++) {
            for (int j = 0; j < height; j++) {
                butcheredImg.setRGB(i, j, -1);
            }
        }

        return butcheredImg;
    }

    public static BufferedImage invertedPixel(BufferedImage butcheredImg) {

        // https://www.geeksforgeeks.org/image-processing-java-set-4-colored-image-negative-image-conversion/?ref=rp

        int width = butcheredImg.getWidth();
        int height = butcheredImg.getHeight();


        for (int i = 0; i < width; i++) {
            for (int j = 0; j < height; j++) {
                int pixel = butcheredImg.getRGB(i, j);

                int red = (pixel >> 16) & 0xff;
                int green = (pixel >> 8) & 0xff;
                int blue = pixel & 0xff;

                red = 255 - red;
                green = 255 - green;
                blue = 255 - blue;

                pixel = (red << 16) | (green << 8) | blue;

                butcheredImg.setRGB(i, j, pixel);

            }
        }
        return butcheredImg;
    }
}
